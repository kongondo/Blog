<?php namespace ProcessWire;

/**
* Markup Blog Module for ProcessWire.
*
* This module gives you Methods to easily output your Blog contents.
* The markup is almost entirely left up to you, the user.
*
* @author Francis Otieno (Kongondo) <kongondo@gmail.com>
* @author Ryan Cramer
*
* Almost 100% original code from Ryan Cramer's Blog Profile.
* Compiled by Kongondo from the functions in Ryan Cramer's Blog Profile to Methods in this Class and where necessary adjusted/added some code.
* Since version 1, the class has been developed further with lots of new methods not in the original code-base.
*
* https://github.com/kongondo/Blog
* Created April 2014
*
* ProcessWire 3.x
* Copyright (C) 2016 by Ryan Cramer
* Licensed under GNU/GPL v2, see LICENSE.TXT
*
* http://www.processwire.com
*
*/

class MarkupBlog  extends WireData implements Module {

	/**
	 * Return information about this module (required).
	 *
	 *	@access public
	 *	@return array module info
	 *
	 */
	public static function getModuleInfo() {

		return array(
			'title' => 'Markup Blog',
			'summary' => 'Markup module to output a Blog based on the Blog Profile by Ryan Cramer',
			'author' => 'Francis Otieno (Kongondo)',
			'version' => '2.4.4',
			'href' => 'https://processwire.com/talk/topic/17105-module-blog/',
			'singular' => true,
			'autoload' => false,
			'requires' => 'ProcessBlog'
		);

	}

	/* ######################### - PROPERTIES - ######################### */

	private $small;
	private $options;
	private $commentsCountTop;
	private $commentsCountBottom;
	private $showFeaturedImage;
	private $featuredImageTop;
	private $numComments;
	private $numCommentsStr;
	private $summaryLimit;
	private $featuredImage;

	/* ######################### - INIT - ######################### */

	/**
	 *	Initialise the module.
	 *
	 *  This is an optional initialisation method called before any execute methods. It will be automatically loaded by ProcessWire.
	 *
	 *	@access public
	 *
	 */
	public function init() {

		$modules = $this->wire('modules');
		$pages = $this->wire('pages');

		$blogConfigs = $modules->getModuleConfigData('ProcessBlog');

		// intialise some properties we'll use throught the class. These contain objects made up of the main blog pages and the main children
		$this->blog	 =		$pages->get($blogConfigs['blog']);
		$this->posts =      $pages->get($blogConfigs['blog-posts']);
		$this->comments =   $pages->get($blogConfigs['blog-comments']);
		$this->authors =    $pages->get($blogConfigs['blog-authors']);
		$this->archives =   $pages->get($blogConfigs['blog-archives']);
		$this->settings =   $pages->get($blogConfigs['blog-settings']);
		$this->dnc =        $pages->get($blogConfigs['blog-dnc']);// disable-new-comments
		$this->dc =         $pages->get($blogConfigs['blog-dc']);// disable-comments
		$this->pauthor =    $pages->get($blogConfigs['blog-pauthor']);

		$this->blogStyle = $blogConfigs['blogStyle'];
		$this->commentsUse = $blogConfigs['commentsUse'];

		// @todo/@note: getting intermittent errors in ProcessWire 3.x, hence this. However, unsure if this is the best way to do it?
		$modules->get('FieldtypeComments');// Load FieldtypeComments in MarkupBlog to ensure that Coment:: constants are available.
	}

	/* ######################### - RENDER MARKUP - ######################### */

	/**
	 * Render a list of tags.
	 *
	 * Each of the tags has a numPosts property containing the number of posts used by the tag.
	 * Also renders an alphabetical jumplist of tags.
	 * As seen on the frontend page: /blog/tags/
	 *
	 * @access public
	 * @param PageArray $tags Blog tags to render.
	 * @param array $options Options to configure rendered tags output.
	 * @return string $jump . $out Generated Blog tags markup.
	 *
	 */
	public function renderTags(PageArray $tags, $options = null) {

		// default options for tags
		// come in the format 'singular,plural' for e.g. 1 'post'
		$defaultOptions = array('tags_posts_text' =>$this->_('post,posts'));

		// merge user options with default tags options
		if($options != null && is_array($options)) $options = array_merge($defaultOptions, $options);
		else $options = $defaultOptions;

		list($singular, $plural) = explode(',', $options['tags_posts_text']);// come in the format 'singular,plural'
		$post = '%d ' . $singular;
		$posts = '%d ' . $plural;

		$lastLetter = '';
		$out = '';
		$letters = array();

		foreach($tags as $tag) {

			$letter = strtoupper(substr($tag->title, 0, 1));// Grab the first letter of the tag title, make it uppercase
			if($letter != $lastLetter) {// if this letter is not equal to the last letter
				if($lastLetter) $out .= "</ul>";
				$out .= "<h3 id='letter_$letter'>$letter</h3>";
				$out .= "<ul class='tags posts-group'>";
				$letters[] = $letter;// add to the letters array
			}
			$lastLetter = $letter;

			// count the number of of posts referencing this $tag
			$numPosts = $tag->references("template=blog-post")->count;
			$numPosts = sprintf(_n($post, $posts, $numPosts), $numPosts);

			$out .= "<li><a href='{$tag->url}'>{$tag->title}</a> <span class='num-posts'>$numPosts</span></li>";
		}

		$out .= "</ul>";

		// $jump is for the alphabetical jumplist that will be output at the top of the tags page
		$jump = '';
		$jump .= "<p class='jumplinks'>";

		foreach($letters as $letter) $jump .= "<a href='./#letter_$letter'>$letter</a> ";

		$jump .= "</p>";

		// return the jumplist and the markup of tags
		return $jump . $out;

	}

	/**
	 * Render previous and next posts links.
	 *
	 * As seen on the frontend page: /blog/post/ = where 'post' is name of the post.
	 *
	 * @access public
	 * @param Page $page The current Blog post page.
	 * @param array $options Options to configure rendered next/prev posts's e.g. << for previous and >> for next
	 * @return string $out Generated navigation markup.
	 *
	 */
	public function renderNextPrevPosts($page, Array $options = null) {

		$date = $page->getUnformatted('blog_date');

		// first sibling of this post whose 'date' is older than this one.
		$prevPost = $page->parent->child("template=blog-post, blog_date<$date, sort=-blog_date");

		// first sibling of this post whose 'date' is newer than this one.
		$nextPost = $page->parent->child("template=blog-post, blog_date>$date, sort=blog_date");

		// default options for next/prev posts
		$defaultOptions = array(
			'prev_post' => '&lt;',// tag/text for previous post, e.g. &laquo;, &#171;, etc, i.e. << >>, etc
			'next_post' => '&gt;',// tag/text for next post, e.g. &rsaquo;, etc
			'prev_post_text' => 'title',// if title or not empty: will show title of the prev post. Otherwise show specificed text, e.g. 'Older entries'
			'next_post_text' => 'title',// if title or not empty: will show title of the next post. Otherwise show specificed text, e.g. 'Newer entries'
		);

		// merge user options with default next/prev options
		if($options != null && is_array($options)) $options = array_merge($defaultOptions, $options);
		else $options = $defaultOptions;

		// only show next/prev string if not empty
		$prev = $options['prev_post'] !='' ? "<span>" . $options['prev_post'] . "</span> " : '';
		$next = $options['next_post'] !='' ? " <span>" . $options['next_post'] . "</span>" : '';

		$prevPostText = $options['prev_post_text'];// previous post's link text
		$nextPostText = $options['next_post_text'];// next post's link text

		// determine if to show next/prev page link title or custom text e.g.
		if ($prevPostText == 'title' ||  $prevPostText =='' || $nextPostText == 'title' ||  $nextPostText =='' ) {
			$prevLinkText = $prevPost->title;
			$nextLinkText = $nextPost->title;
		}

		else {
			$prevLinkText = $prevPostText;
			$nextLinkText = $nextPostText;
		}

		$out = "<div class='next-prev-posts'>";

		// show next/prev post links if available
		if($prevPost->id > 0) $out .= "<p class='prev-post'>" . $prev . "<a href='" . $prevPost->url . "'>" . $prevLinkText . "</a></p>";
		if($nextPost->id > 0) $out .= "<p class='next-post'><a href='" . $nextPost->url . "'>" . $nextLinkText . "</a>" . $next . "</p>";

		$out .= "</div>";

		return $out;

	}

	/**
	 * Render a limited number of comments RSS.
	 *
	 * As seen on the frontend page: /blog/comments/rss/.
	 *
	 * @access public
	 * @param integer $limit Number of comments to render.
	 *
	 */
	public function renderCommentsRSS($limit) {

		// selector to locate the comments we want
		$start = 0;
		$selector = "limit=$limit, start=$start, sort=-created, status>=" . Comment::statusApproved;

	    // find the comments we want to output
	    $comments = $this->findComments($selector);

		$commentPages = new PageArray();

		foreach($comments as $comment) {

			$p = $this->wire('pages')->get($comment->pages_id);
			if(!$p->id) continue;

			$p = clone $p;
			$p->comment_title = htmlentities($comment->cite, ENT_QUOTES, "UTF-8") . " reply to: " . $p->title;
			$p->comment_body = htmlentities($comment->text, ENT_QUOTES, "UTF-8");
			$p->comment_date = $comment->created;

			$commentPages->add($p);
		}

		$rss = $this->wire('modules')->get('MarkupRSS');
		$rss->title = $this->wire('pages')->get('/')->headline . ' - ' . $this->wire('page')->get('headline|title');
		$rss->itemTitleField = 'comment_title';
		$rss->itemDescriptionField = 'comment_body';
		$rss->itemDescriptionLength = 0;
		$rss->itemDateField = 'comment_date';
		$rss->render($commentPages);

	}

	/**
	 * Render a list of categories, optionally showing a few posts from each.
	 *
	 * @access public
	 * @param PageArray $categories Category pages to return.
	 * @param integer $showNumPosts Number of posts to show from each category (default=0).
	 * @param array $options Options to configure rendered categories output.
	 * @return string $out Generated markup of Blog categories.
	 *
	 */
	public function renderCategories(PageArray $categories, $showNumPosts = 0, Array $options = null) {

		// default options for categories
		$defaultOptions = array(
			'categories_posts_text' =>$this->_('post,posts'),// come in the format 'singular,plural' for e.g. October 5 'posts'
			'categories_not_found' => $this->_('No categories to display.'),// message when no posts found
			'categories_more_text' => $this->_('View More'),// link text to view all posts in that category
		);

		// merge user options with default categories options
		if($options != null && is_array($options)) $options = array_merge($defaultOptions, $options);
		else $options = $defaultOptions;

		$out = '';

		if(count($categories)){

			list($singular, $plural) = explode(',', $options['categories_posts_text']);// come in the format 'singular,plural'
			$cpost = '%d ' . $singular;
			$cposts = '%d ' . $plural;

			foreach($categories as $category) {

				$out .=
					 "<div class='category'>
						<h3><a href='$category->url'>$category->title</a></h3>";

				// find a limited number of posts that reference this category
				$category->posts = $category->references("template=blog-post,limit={$showNumPosts},, sort=-blog_date");

				$n = $category->posts->getTotal();

				$out .= "<span class='num-posts'>" . sprintf(_n($cpost, $cposts, $n), $n);
				$out .= "<a class='rss' href='$category->url" . "rss'>" . $this->_('RSS') . "</a></span>";

				if($n){
					$out .= "<ul class='category-posts posts-group'>";
					foreach($category->posts as $post) $out .= "<li><a href='$post->url'>$post->title</a></li>";
					// if more posts available than the limit we have set, show "view more" link
					if($n > count($category->posts)) $out .= "<li><a class='more' href='$category->url'>" . $options['categories_more_text'] . "</a></li>";
					$out .= "</ul>";
				}// end if($n);

				$out .= "</div>";

			}// end foreach $categories

		}// end if count $categories

		else $out .= "<p class='no-categories'>" . $options['categories_not_found'] . "</p>";

		return $out;

	}

	/**
	 * Render blog archives for a given year.
	 *
	 * Used by the /site/templates/blog-archives.php template.
	 * Render archives returned by the getArchives() method.
	 * Archives links include a year headline followed by a list of months in that year with posts,
	 * and the number of posts in each month.
	 *
	 * @access public
	 * @param array $years as returned by getArchives() method.
	 * @param array $options Options to configure rendered archives output.
	 * @return string $out Generated Blog archives markup.
	 *
	 */
	public function renderArchives(Array $years, Array $options = null) {

		$out = '';

		// default options for archives
		$defaultOptions = array(
			'archives_posts_text' =>$this->_('post,posts'),// come in the format 'singular,plural' for e.g. October 5 'posts'
			'archives_month_view_all_text' => $this->_('View All'),// 'view all' that month's archives if limit set on amount to list
		);

		// merge user options with default archives options
		if($options != null && is_array($options)) $options = array_merge($defaultOptions, $options);
		else $options = $defaultOptions;

		list($singular, $plural) = explode(',', $options['archives_posts_text']);// come in the format 'singular,plural'
		$post = '%d ' . $singular;
		$posts = '%d ' . $plural;

		foreach($years as $year=>$y) {

			$year 	=  $y['name'];
			$total 	=  $y['total'];
			$months =  $y['months'];// this is an array
			$url 	=  $y['url'];


			$out .= "<div class='archive'>
					<h3><a href='$url'>$year</a></h3>
					<span class='num-posts'>" . sprintf(_n($post, $posts, $total), $total) . "</span>";

			$out .= "<ul class='posts-group'>";

			foreach($months as $monthNum => $month){

				$out .= "<li><a href='" . $month['url'] . "'>" . $month['name'] . "</a>";
				$out .=  "<span class='num-posts'>" . sprintf(_n($post, $posts, $month['total']), $month['total']) . "</span>";

				if(count($month['posts'])) {// posts will be empty if $blog->archives() call specified 0 for limit;
					$out .= "<ul>";
					foreach($month['posts'] as $item){
						$out .= "<li><a href='$item->url'>$item->title</a></li>";
					}

					if($month['total'] > count($month['posts'])){
						$out .= "<li><a class='more' href='" . $month['url'] . "'>" . $options['archives_month_view_all_text'] . "</a></li>";
					}

					$out .=  "</ul>";
				}

				$out .=  "</li>";

			}// end foreach $months as $monthNum

			$out .= "</ul></div>";


		}// end foreach $years as $year

		return $out;

	}

	/**
	 * Renders a list of Blog authors.
	 *
	 * @access public
	 * @param PageArray $authors Author pages.
	 * @return string $out Generated markup of Blog Authors.
	 *
	 */
	public function renderAuthors(PageArray $authors) {

		$out = "<ul class='authors posts-group'>";

		foreach($authors as $author) {
			$numPosts = $this->wire('pages')->count("template=blog-post, created_users_id=$author");
			// $numPostsStr = sprintf(_n('%d post', '%d posts', $author->numPosts), $author->numPosts);// not in use
			// Note: $author->url2 is the blog-generated version, since $author->url is in the admin.
			$authorName = $author->get('title') ? $author->get('title') : 'Author Name';// use generic 'Author Name' if author title not set
			$out .= "<li><a href='{$author->url2}'>" . $authorName . "</a> <span class='num-posts'>$numPosts</span></li>";
		}

		$out .= "</ul>";

		return $out;

	}

	/**
	 * Return PageArray of posts related to the current post.
	 *
	 * The returned PageArray can then be used with renderNav() to list the related posts.
	 *
	 * @access public
	 * @param Page $post limit of maximum related posts to find.
	 * @param integer $relatedBy criteria for finding  related posts.
	 * @param integer $limit Find this limited number of related posts.
	 * @param string $sort prioritise related posts to find, especially when limit set.
	 * @return PageArray|null $related Related posts or null if none found.
	 *
	 */
	public function renderRelatedPosts(Page $post = null, $relatedBy = null, $limit = null, $sort = null) {

		if(is_null($post)) $page = $this->wire('page');
		else $page = $post;
		if(!$page instanceof Page) throw new WireException('renderRelatedPosts requires a Page');

		$pages = $this->wire('pages');
		$related = null;
		$selector = '';

		// set defaults
		$relatedBy = $relatedBy === null ? $relatedBy = 1 : $relatedBy;
		$limit = $limit === null ? $limit = 3 : $limit;
		$sort = $sort === null ? $sort = '-blog_date' : $sort;

		// sanitize submitted sort selector value. Default is sort by latest post
		$sort = $this->wire('sanitizer')->selectorValue($sort);

		// find related posts by given criteria. Default is to relate by both tags AND categories
		if($relatedBy == 1 && count($page->blog_tags) && count($page->blog_categories)) $selector = "blog_tags=$page->blog_tags, blog_categories=$page->blog_categories";
		elseif($relatedBy == 2 && count($page->blog_tags)) $selector = "blog_tags=$page->blog_tags";// relate by tags only
		elseif($relatedBy == 3 && count($page->blog_categories)) $selector = "blog_categories=$page->blog_categories";// relate by categories only

		// find related posts
		if($selector) $related = $pages->find("template=blog-post, id!=$page->id, limit=$limit, sort=$sort, $selector");

		return $related;

	}

	/**
	 * Render a list of comments.
	 *
	 * If page is editable, then non-approved comments will be included (and identified) in the list.
	 *
	 * @access public
	 * @param CommentArray $comments.
	 * @param integer $limit Optional limit of maximum comments to show.
	 * @param array $options Optional text describing a post's commenting status (e.g. 'comments not allowed').
	 * @return string $out Comments markup.
	 *
	 */
	public function renderComments(CommentArray $comments, $limit = 0, Array $options = null) {

		$out = '';
		$page = $this->wire('page');// Page being viewed (Page)
		$admin = $page->editable();
		$cnt = 0;
		$pageNum = $this->wire('input')->pageNum;
		$commentArray = new CommentArray();
		$prevURL = '';// URL for previous pagination, if applicable (string)
		$nextURL = '';// URL for next pagination, if applicable (string)

		// global AND post's comments/comments form visibility state. Note: post's comments/comments form SELECTED visibility status overrides global setting
		$noCommentsForm = false;
		$noNewComments = '';
		$blogComments = $this->comments;

		$gComments = $blogComments->blog_comments_view;// global comments/comments form visibility setting [only kicks in when selected AND post setting='']
		$gCmntsCnt = $blogComments->blog_comments_max;// global: maximum comments allowed per post [form will be hidden if this limit exceeded]. Note: this overrides post's 'always show comments' form
		$pComments = $page->blog_comments_view;// post comments/comments form visibility setting [only kicks in when SELECTED]
		$pCmntsCnt = count($page->blog_comments);
		$defaultOptions = array(
			'comments_closed' => $this->_('Comments closed for this post.'),// string: message when comments closed
			'comments_disallowed' => $this->_('Comments not allowed for this post.'),// string: message when comments not allowed for post
			'comments_empty' => $this->_('Be the first to comment'),// string: message when there are no comments for post
			'comments_login' => $this->_('You need to log in to comment.'),// string: message when comment form hidden until user logs in
			'comments_login_required' => false,// bool: if user needs to login before commenting [default is false - they don't need to log in first]
			'comments_success' => $this->_('Thank you, your submission has been saved.'),
			'comments_error' => $this->_('Your submission was not saved due to one or more errors. Try again.'),
			'comments_text' => $this->_('Comment,Comments'),// comments text, e.g. 2 'Comments' or 1 'Comment' next to comments count (div#comments). Must be in 'singular,plural' format
			'comments_list_empty' => $this->_('No comments found.'),
			'comments_list_reply_text' => $this->_('replied to'),
			'comments_by_text' => $this->_('Comment by'),
			'comments_post_text' => $this->_('Post a comment'),
			'comments_prev_text' => $this->_('Back'),
			'comments_next_text' => $this->_('Next'),
		);

		// merge user options with default comments options
		if($options != null && is_array($options)){$options = array_merge($defaultOptions, $options);}
		else {$options = $defaultOptions;}

		if (($pComments && $pComments->id==$this->dnc->id) || ($gComments && $gComments->id==$this->dnc->id && !$pComments) || ($gCmntsCnt && $pCmntsCnt > $gCmntsCnt)) {
			$noCommentsForm = true;// will use later to disable showing comments form
			// only need to show this on 'blog-post' pages not in 'blog-comments'!
			if($page->template == 'blog-post') $noNewComments =  '<h4 id="comments-closed">' . $options['comments_closed'] . '</h4>';// save to a variable; will use later below
		}

		elseif (($pComments && $pComments->id==$this->dc->id) || ($gComments && $gComments->id==$this->dc->id && !$pComments)) {
			if ($page->template=='blog-post') return '<div id="comments"><h4 id="comments-disallowed">' . $options['comments_disallowed'] . '</h4></div><!--/#comments-->';
		}

		// check if we should introduce pagination
		if($limit && (count($comments) > $limit || $pageNum > 1)) {
			if($pageNum > 2) $prevURL = $page->url . 'page' . ($pageNum-1);
			elseif($pageNum > 1) $prevURL = $page->url;
			else $prevURL = '';
			if(count($comments) > $limit) $nextURL = $page->url . 'page' . ($pageNum+1);
			else $nextURL = '';
		}

		// setup comments for output, copying all comments we will display into $commentArray
		foreach($comments as $c) {
			if(!$admin && $c->status != Comment::statusApproved) continue;
			$c->date = $this->formatDate($c->created, 2);
			$commentArray->add($c);
			$cnt++;
			if($limit && $cnt >= $limit) break;
		}


		$out .= "<div id='comments'>";

		if($page->template == 'blog-post') {
			// if we are viewing a post page, then start with a headline
			$n = count($commentArray);
			if($n) {
				$out .= "<span class='num-comments-icon'>$n</span>";
				list($comment, $comments) = explode(',', $options['comments_text']);// come in the format 'singular,plural'
				$out .= "<h4>" . sprintf(_n($comment, $comments, $n), $n) . "</h4>";
			}
		}

		if(count($commentArray)) {

			// output the individual comments if comments found
			$out .= "<ul class='comments CommentList'>";

			foreach($commentArray as $c) {

				$out .= "<li class='comment CommentListItem' id='comment" . $c->id . "'>
							<p class='comment-head CommentHeader'>";

				$cite = htmlentities($c->cite, ENT_QUOTES, "UTF-8");
				$website = htmlentities($c->website, ENT_QUOTES, "UTF-8");

				if($website) $cite = "<a href='$website' rel='nofollow' target='_blank'>$cite</a>";

				if($page->template == 'blog-post')	$out .= sprintf(__('%1$s %2$s on %3$s'), $options['comments_by_text'], $cite, $c->date);
				else {
					$out .= "<a href='{$c->page->url}#comment{$c->id}'>";
					$out .= sprintf(__('%1$s  %2$s %3$s on %4$s'), $cite, $options['comments_list_reply_text'], $c->page->title, $c->date);
					$out .= "</a>";
				}

				if($c->status == Comment::statusPending) $out .= " <span class='comment-status-pending'>" . $this->_('PENDING') . "</span>";
				elseif($c->status == Comment::statusSpam) $out .= " <span class='comment-status-spam'>" . $this->_('SPAM') . "</span>";
				elseif($c->page->blog_comments_view && $c->page->blog_comments_view->id == $this->dc->id || !$c->page->blog_comments_view && $gComments && $gComments->id==$this->dc->id)
						$out .= " <span class='comment-status-hidden'>" . $this->_('HIDDEN') . "</span>";

				$out .= "</p>
							<div class='comment-body CommentText'>";

				$text = htmlentities($c->text, ENT_QUOTES, "UTF-8");// grab the comment text
				$text = str_replace("\n\n", "</p><p>", $text);
				$text = str_replace("\n", "<br />", $text);

				$out .=  "<p>$text</p>
						</div></li>";

			}// end foreach commentArray

			$out .= "</ul>";


		}// end if(count($commentArray))

		// if comments count == 0
		elseif(!count($commentArray)) {
			// prevents output of 'be the first to comment' when comments closed but there are no comments yet
			if(($page->template=='blog-post' && $pComments && $pComments->id !=$this->dnc->id) || ($page->template=='blog-post' && !$pComments && !$gComments)) {
				$out .= '<h4 id="comments-empty">' . $options['comments_empty'] . '</h4>';
			}
			elseif ($page->template=='blog-comments') $out .= '<h4 id="comments-empty">' .  $options['comments_list_empty'] . '</h4>';
		}

		if($page->template == 'blog-post' && $noCommentsForm == false) {
			if (($options['comments_login_required'] && $this->wire('user')->isLoggedin()) || (!$options['comments_login_required'])) {
				$commentsFormOptions = $this->getCommentsFormOptions($options);
				// if we are viewing a post page, then output a comments form
				$out .= $page->blog_comments->renderForm($commentsFormOptions);
				$out .=  "</div><!--/#comments-->";
			}

			else $out .=  '<h4 id="comments-login">' . $options['comments_login'] . '</h4></div><!--/#comments-->';

		}// end if $page->template == "blog-post" && $noCommentsForm == false

		else $out .= $noNewComments . '</div><!--/#comments-->';

		// output pagination if necessary
		if($prevURL || $nextURL) {
			$out .= "<p class='comments-pagination'>";
			if($prevURL) $out .= "<a class='button button-prev' href='$prevURL'>" . $options['comments_prev_text'] . "</a> ";
			if($nextURL) $out .= "<a class='button button-next' href='$nextURL'>" . $options['comments_next_text'] . "</a> ";
			$out .= "</p>";
		}

		return $out;

	}

	/**
	 * Render a Blog post's author widget.
	 *
	 * @access public
	 * @param array $options Options to configure post author widget.
	 * @return string $out Markup of widget.
	 *
	 */
	public function postAuthor(Array $options = null) {

		$postAuthor = $this->pauthor;

		// default options for author widget
		$defaultOptions = array(
			'author_text' => $this->_('Author'),// text next to author title|name
			'author_thumb_width' => 100,// no width manipulation of author thumb if this is blank or 0
			'author_thumb_height' => '',// no height manipulation of author thumb if this is blank or 0
			'author_thumb_alt' => 'title',// defaults to $author->title. Otherwise other stated field on the page, e.g. = 'title' or if 'description' then $image->description

		);

		// merge user options with default author widget options
		if($options != null && is_array($options)) $options = array_merge($defaultOptions, $options);
		else $options = $defaultOptions;

		$out = '';

		// if widget is available [i.e. published]...
	    if (!$postAuthor->is(Page::statusUnpublished)) {

			$author = $this->wire('page')->createdUser;
			$authorName = $author->get('title') ? $author->get('title') : 'Author Name';// if no author title not set use generic 'Author Name'

			$image = $author->blog_images->first();

			$authorText = $options['author_text'] !='' ? "<small> " . $options['author_text'] . "</small>" : '';

			if($image) {
				$alt = $options['author_thumb_alt'] == 'description' ? $image->description : $author->{$options['author_thumb_alt']};
				$width 	= (int) $options['author_thumb_width'];
				$height = (int) $options['author_thumb_height'];
				if ($width > 0) $thumb = $image->width($width);
				elseif ($height > 0) $thumb = $image->height($height);
				else $thumb = $image;
				$photo =  "<a title='$authorName'>
							<img class='author-photo' src='{$thumb->url}' alt='{$alt}' width='{$thumb->width}' height='{$thumb->height}' >
							</a>";
			}

			else $photo = '';

			$out .= "<div id='post-author' class='clearfix'>" . $photo . "<h4 class='post-author-name'>" . $authorName . $authorText . "</h4>" . $author->blog_body . "</div>";

	    }

		return $out;

	}

	/**
	 * Render an RSS feed of the given pages.
	 *
	 * Note that you should not output anything further after calling this, as it outputs the RSS directly.
	 *
	 * @access public
	 * @param PageArray $items Pages to include in the feed.
	 * @param string $title Title of the feed. If not provided, pulled from current page.
	 * @param string $description Description of the feed. If not provided, pulled from current page.
	 *
	 */
	public function renderRSS(PageArray $items, $title = '', $description = '') {

		$page = $this->wire('page');
		if(empty($title)) $title = $page->get('headline|title') . ' - ' . $this->wire('pages')->get('/')->headline;
		if(empty($description)) $description = $page->get('summary|meta_description');// @todo - no page summary so change to get from blog_body instead?

		$rss = $this->wire('modules')->get('MarkupRSS');
		$rss->title = $title;
		$rss->description = $description;
		$rss->itemDescriptionField = 'body';
		$rss->itemDescriptionLength = 0; // no maxlength
		$rss->itemDateField = 'date';
		$rss->render($items);

	}

	/**
	 * Render a secondary navigation.
	 *
	 * When the $mobile option is set, make the ul.nav disappear when at mobile width.
	 * and instead show only the form <select> navigation instead.
	 * This happens because the css media query recognizes the 'no-mobile' class.
	 * and hides any thing carrying that class. Likewise, anything with the 'mobile'.
	 * class is only shown when at mobile width.
	 *
	 * @access public
	 * @param string $headline Headline to display above nav
	 * @param array|PageArray $items May be an array of Page objects or array of ($url => $label)
	 * @param Page|string $currentURL Current item that should be highlighted, may be Page or $url
	 * @param bool $mobile Replace the nav with a <select> when at mobile width?
	 * @return string $out Generated navigation markup.
	 *
	 */
	public function renderNav($headline, $items, $currentURL = '', $mobile = true) {

		if(!count($items)) return '';

		if($currentURL instanceof Page) {
			$currentPage = $currentURL;
			$currentURL = $currentPage->url;
		}
		else $currentPage = null;

		$nav = array();

		if ($this->blogStyle == 1 || $this->blogStyle == 2) $blogParentId = $this->blog->id;
		elseif ($this->blogStyle == 3 || $this->blogStyle == 4) $blogParentId = 1;

		foreach($items as $url => $title) {

			if($title instanceof Page) {

				$page = $title;
				$title = $page->title;
				$url = $page->url;

				// if nav item is root-level and $currentPage shares this root parent, then
				// make it the currentURL so that it is still highlighted in the nav

				/* ORIGINAL CODE in Blog Profile. My Page Tree is different, hence amended below */
				// if($page->parent_id == 1 && $currentPage && $currentPage->rootParent === $page) $currentURL = $currentPage->rootParent->url;

				/* @kongondo above amendment */
				if($page->parent_id == $blogParentId && $currentPage && $currentPage->parent === $page) $currentURL = $currentPage->parent->url;
			}

			$nav[$url] = $title;

		}

		$out = '';

		if($headline) $out .= "<h4 class='nav-headline'>$headline</h4>";

		$class = 'nav links';

		if($mobile) $class .= ' no-mobile'; // hides the ul.nav when mobile width

		$out .= "<ul class='$class'>";

		// $nav is the array we populated earlier with the $url and $title of each $item
		foreach($nav as $url => $title) {
			if($url == $currentURL) $out .= "<li class='on'><a class='on' href='$url'>$title</a></li>";
			else $out .= "<li><a href='$url'>$title</a></li>";
		}

		$out .= "</ul>";

		/*
		 * here's where we display the mobile select navigation. The form we put here
		 * has the class 'mobile' so it is only visible when at mobile width.
		 *
		 */
		if($mobile) {

			$out .= "<form class='mobile'>
						<select class='nav'><option value='./'></option>";

			// $nav is the array we populated earlier with the $url and $title of each $item
			foreach($nav as $url => $title) {
				$selected = $url == $currentURL ? " selected='selected'" : '';
				$out .=  "<option$selected value='$url'>$title</option>";
			}

			$out .= "</select>
					</form>";
		}

		return $out;

	}

	/**
	 * Given a items of blog entries generate and return the output.
	 *
	 * @access public
	 * @param PageArray|Page|String $posts The entries to generate output for.
	 * @param bool $small Set to true if summarized versions of posts are required. Default is false.
	 * @param array $options Options to configure posts' output.
	 * @return string $out The generated post markup.
	 *
	 */
	public function renderPosts($posts, $small = false, Array $options = null) {

		$posts = $this->processPosts($posts);
		$this->options = $this->processPostsOptions($options);
		$options = $this->options;
		$this->small = $small;

		// excerpt/post truncated length
		$limit = $this->settings->blog_small;
		$this->summaryLimit = $limit ? $limit : 450;

		// start output
		$out = '';

		// Small means show truncated body text. 'Large' just means show the whole/full body text
		if($this->small && $options['post_count'] !=0) {
			// display a headline indicating quantities
			$start = $posts->getStart()+1;
			$end = $start + count($posts)-1;
			$total = $posts->getTotal();

			if($total) $out .= "<h3 class='posts-count'>" . $options['post_count_text'] . " " . sprintf(__('%1$d to %2$d of %3$d'), $start, $end, $total) . "</h3>";

		}// end if($small)

		#------------------------------------------- POSTS WRAPPER ------------------------------------------- #

		$out .= $this->small ? "<div class='posts posts-small'>" : "<div class='posts'>";

		// COMMENTS COUNT: for post comments count
		$this->commentsCountTop = false;
		$this->commentsCountBottom = false;

		// post comments - only if commentsUse == 1
		if($this->commentsUse == 1 && $options['post_comments'] !=0) {
			// if we found comments
			list($singular, $plural) = explode(',', $options['post_comments_text']);// come in the format 'singular,plural'
			$comment = '%d ' . $singular;
			$comments = '%d ' . $plural;
			if($options['post_comments'] == 1 || $options['post_comments'] == 3) $this->commentsCountTop = true;
			if($options['post_comments'] == 2 || $options['post_comments'] == 3) $this->commentsCountBottom = true;
		}

		// FEATURED IMAGE: determine if to output featured image in posts
		$this->showFeaturedImage = false;
		$this->featuredImageTop = false;// for positioning featured image (top/bottom)

		// if featured image is to be output
		if (($this->small && $options['post_small_image'] !=0) || (!$this->small && $options['post_large_image'] !=0)) $this->showFeaturedImage = true;// we will be outputting a featured image


		// loop through and output posts
		foreach($posts as $page) {

			// set each post page's summary, author-name and author-url
			$this->setExraProperties($page);

			// if showing full posts, set the post's categories and tags as properties for each post
			if(!$this->small) {
				$this->setCategories($page);
				$this->setTags($page);
			}

			// post comments - only if commentsUse == 1
			if($this->commentsCountTop == true || $this->commentsCountBottom == true) {
				$this->numComments = $page->blog_comments->count();
				if($this->numComments > 0) $this->numCommentsStr = sprintf(_n($comment, $comments, $this->numComments), $this->numComments);
				else $this->numCommentsStr = $options['post_zero_comments_text'];// used as both title of icon anchor tag when no comments + in post-foot when no comments yet
			}


			#------------------------------------------- FEATURED IMAGE ------------------------------------------- #

			$this->featuredImage = '';// will contain featured image string
			// if featured image is to be output
			if ($this->showFeaturedImage == true) {
				$this->featuredImage = $this->getFeaturedImage($page);
				// determine featured image position. in here we already know there is an image; we just don't know if user wants it at the top or bottom
				if(($this->featuredImage !='' && $options['post_small_image'] == 1) || ($this->featuredImage !='' && $options['post_large_image'] == 1)) $this->featuredImageTop = true;
			}// end if featured image specified


			# ******************************** SINGLE POST START + POST HEAD ******************************** #


			#------------------------------------------- POST HEADLINE ------------------------------------------- #

			$out .= $this->renderPostHead($page);


			#------------------------------------------- POST BODY ------------------------------------------- #

			$out .= "<div class='post' id='{$page->id}'>";
			$out .=	"<div class='post-body'>";

			// if featured image to be output below post-body
			if($this->featuredImageTop == false) $out .= $this->featuredImage;

			// if to output 'View More' link (if post $small)
			if($this->small) {
				$tag = $options['post_small_tag'];
				$out .= "<$tag  class='post-small'>" . $page->summary . "&hellip; <a class='more' href='{$page->url}'>" . $options['post_more_text'] . "</a></$tag>";
			}

			else $out .= $page->blog_body;

			// Note: Left here for posterity. We are not including a gallery in this version
			// if the post has images and no <img> tags in the body, then make it a gallery
			// if(count($page->images) && strpos($page->body, '<img ') === false) include("./gallery.php");

			$out .= "</div>";// end div.post-body

			#------------------------------------------- POST FOOT ------------------------------------------- #

			// output footer markup if showing FULL post
			if(!$this->small) $out .= $this->renderFooter($page);

			$out .= "</div>";// end div.post => single post


		}// end 	foreach($posts as $page)

		if(!count($posts)) $out .= '<h4 id="no-posts">' . $options['post_not_found'] . '</h4>'; // <!--/.posts-->

		$out .= "</div>";/*end div.posts => posts wrapper*/


		#------------------------------------------- POST PAGINATION ------------------------------------------- #

		// if there are more posts than the specified limit, then output pagination
		$out .= $this->renderPagination($posts);

		return $out;

	}

	/**
	 * Renders markup of a Blog post's headline.
	 *
	 * Used by renderPosts().
	 *
	 * @access private
	 * @param Page $page The post to generate a headline for.
	 * @return string $out The generated markup.
	 *
	 */
	private function renderPostHead($page) {

		$options = $this->options;
		$numCommentsStr = $this->numCommentsStr;
		$numComments = $this->numComments;
		$out = '';

		$out .= "<div class='post-head'>";

		// @note: moved below $featuredImageTop
		// if($commentsCountTop == true) $out .= "<a class='num-comments-icon' href='{$page->url}#comments' title='$numCommentsStr'>$numComments</a>";

		// headline size
		$h = $this->small ? $options['post_small_headline_tag'] : $options['post_large_headline_tag'];


		#------------------------------------------- POST HEADLINE ------------------------------------------- #

		// if featured image to be output above post-headline
		if($this->featuredImageTop == true) $out .= $this->featuredImage;
		if($this->commentsCountTop == true) $out .= "<a class='num-comments-icon' href='{$page->url}#comments' title='$numCommentsStr'>$numComments</a>";

		$out .= "<$h class='post-headline'><a href='{$page->url}'>{$page->title}</a></$h>";

		// meta/byline post_author_text
		$author = $options['post_author'] == 1 ? "<span class='author'>" . $options['post_author_text'] . " " . "<a href='{$page->authorURL}'>{$page->authorName}</a></span> " : '';
		$date = $options['post_date'] == 1 ? "<span class='date'>" . $options['post_date_text'] . " " . $page->blog_date . "</span>" : '';

		// if page is editable (i.e., appropriate person logged in), let's show an edit link to the post
		$editURL = $this->wire('config')->urls->admin . "page/edit/?id={$page->id}'>";
		$edit = $page->editable() && $options['post_edit'] == 1 ? "<span class='edit'>(<a href='" . $editURL . $this->_('edit') . "</a>)</span>" : '';

		if(!empty($author) || !empty($date) || !empty($edit)) $out .= "<p class='post-byline'>" . $author . $date . $edit . "</p>";// end p.post-byline

		// show post categories and tags if user wants them at the 'top'
		if($options['post_categories'] == 1) $out .= $page->categories;
		if($options['post_tags'] == 1) $out .= $page->tags;

		$out .= "</div>";// end div.post-head

		return $out;

	}

	/**
	 * Render footer items for a full post.
	 *
	 * Used by renderPosts().
	 *
	 * @access private
	 * @param Page $page A single post page to set categories property to.
	 * @return string $out Markup of posts' footer.
	 *
	 */
	private function renderFooter($page) {

		$options = $this->options;
		$numCommentsStr = $this->numCommentsStr;

		$out = '';

		// if post author OR post date are to be displayed at the 'bottom' == 2
		$author = $options['post_author'] == 2 ? $author = "<span class='author'>" . $options['post_author_text'] . " " . "<a href='{$page->authorURL}'>{$page->authorName}</a></span> " : '';
		$date = $options['post_date'] == 2 ? $date = "<span class='date'>{$page->blog_date}</span>" : '';

		$editURL = $this->wire('config')->urls->admin . "page/edit/?id={$page->id}'>";
		$edit = $page->editable() && $options['post_edit'] == 2 ? "<span class='edit'>(<a href='" . $editURL . $this->_('edit') . "</a>)</span>" : '';

		// if post_categories OR post_tags are to be displayed at the 'bottom' == 2 + number of comments	in 'large' posts
		$categories = $options['post_categories'] == 2 ? $page->categories : '';
		$tags = $options['post_tags'] == 2 ? $page->tags : '';

		$comments = $this->commentsCountBottom == true ? "<p class='num-comments'><span>" . $options['post_comments_label'] . "</span> <a href='{$page->url}#comments'>$numCommentsStr</a></p>" : '';

		if(!empty($author) || !empty($date) || !empty($edit)  || !empty($categories) || !empty($tags) || !empty($comments)) {
			$out .= "<div class='post-foot'>" . $author . $date . $edit . $categories . $tags . $comments . "</div>";// end div.post-foot
		}

		return $out;

	}

	/**
	 * Render posts' pagination if necessary.
	 *
	 * Used by renderPosts().
	 *
	 * @access private
	 * @param PageArray $posts Posts to paginate.
	 * @return string $out Markup of posts' pagination.
	 *
	 */
	private function renderPagination($posts) {
		$options = $this->options;
		$out = '';
		if($posts->getLimit() < $posts->getTotal()) {
			$markupPagerNavOptions = is_array($options['post_pagination']) && count($options['post_pagination']) ? $options['post_pagination'] : '';
			$out .= $posts->renderPager($markupPagerNavOptions);
		}
		return $out;
	}

	/* ######################### - UTILITIES - ######################### */

	/**
	 * Gets posts to render.
	 *
	 * Used by renderPosts().
	 *
	 * @access private
	 * @param PageArray|Page|String $posts The entries to generate output for.
	 * @return PageArray $posts Posts to render.
	 *
	 */
	private function processPosts($posts) {

		if(!$posts instanceof PageArray) {
			// single page
			if($posts instanceof Page) {
				$post = $posts;
				$posts = new PageArray();
				$posts->add($post);
			}
			// selector string
			elseif(is_string($posts)) {
				$selector = $posts;
				$posts = $this->wire('pages')->find("template=blog-post, sort=-blog_date, $selector");
			}
			else throw new WireException('renderPosts requires a PageArray, Page or selector string');

		}// end if(!$posts instanceof PageArray)

		return $posts;

	}

	/**
	 * Return merged user and default options for posts.
	 *
	 * Used by renderPosts().
	 *
	 * @access private
	 * @param array $options Array of custom options to merge wth default ones.
	 * @return array $options Options to apply to rendered posts.
	 *
	 */
	private function processPostsOptions($options) {

		// default options for various aspects of posts
		$defaultOptions = array(

			'post_count' => 1,// 0=off, 1=on - for the count in: Posts 1 to 5 of 15
			'post_count_text' =>$this->_('Post'),// e.g. Posts 1 to 5 of 15
			'post_not_found' => $this->_('No posts found.'),// message when no posts found
			'post_author' => 1,// display name of post author: 0=off,1=top(below post-headline),2=bottom(in post-foot)
			'post_author_text' => $this->_('Posted by'),//
			'post_date' => 1,// display post's date: 0=off,1=top(below post-headline),2=bottom(in post-foot)
			'post_date_text' => '',// e.g. Posted by author 'on' date
			'post_edit' => 1,// display post's edit: 0=off,1=top(below post-headline),2=bottom(in post-foot)
			'post_more_text' => $this->_('View More'),// for $small posts - link text to full post
			'post_categories' => 2,// display post's categories: 0=off,1=top(below post-byline),2=bottom(in post-foot)
			'post_categories_text' => $this->_('Categories:'),// e.g. 'Categories', 'In', 'Filed under', etc
			'post_tags' => 2,// display post's tags: 0=off,1=top(below post-byline),2=bottom(in post-foot)
			'post_tags_text' => $this->_('Tags:'),// e.g. 'Tagged', 'Related', etc
			'post_small_allowable_tags' => '',// holds string of HTML tags for strip_tags $allowable_tags. Needs to be in format '<code><p><img>'
			'post_small_headline_tag' => 'h4',
			'post_large_headline_tag' => 'h2',
			'post_small_tag' => 'p',

			// post comments
			'post_comments' => 1,// show comments info? 0=off,1=comments count top,2=comments count bottom,3=comments count top & bottom
			'post_zero_comments_text' => $this->_('No comments yet'),
			'post_comments_text' => $this->_('Comment,Comments'),// title in anchor comments icon + post-foot comments text, e.g. '2 Comments' or '1 Comment'. Must be in 'singular,plural' format
			'post_comments_label' => $this->_('Comments:'),// this appears in post-foot, e.g. 'Comments': 2 Comments

			// ## featured images ##
			/*	@note:
				- for large posts one cannot use an embedded image as the featured image.
				- They will need to designate a featured image.
				- For small posts, both embedded and images tagged 'featured' will be picked up as featured images.
			*/

			'post_image_alt' => 'description',// defaults to $image->description. Otherwise other stated field on the page, e.g. = 'title'
			'post_image_tag' => 'featured',// string: image tag to look for in blog_images

			// ** small/truncated post featured image **
			'post_small_image' => 0,// display post's featured image: 0=off,1=top(above post-headline),2=bottom(first item in post-body)
			'post_small_image_width' => '',// no width manipulation of featured image if this is blank or 0
			'post_small_image_height' => '',// no height manipulation if this is blank or 0. Note, if size is true and both width and height > 0, use size() instead

			/*size:
				-	image will be resized to exact dimensions -> $img = $image->size($x, $y)
				-	where $x = 'width' and $y = 'height'*/
			'post_small_image_size' => false,// if 'size' = true AND both width and height > 0, this kicks in

			// ** large/full post featured image **
			'post_large_image' => 0,// display post's featured image: 0=off,1=top(above post-headline),2=bottom(first item in post-body)
			'post_large_image_width' => '',// no width manipulation of featured image if this is blank or 0
			'post_large_image_height' => '',// no height manipulation if this is blank or 0. Note, if size is true and both width and height > 0, use size() instead
			'post_large_image_size' => false,// if 'size' = true AND both width and height > 0, this kicks in

			// MarkupPagerNav options
			'post_pagination' => array(),

		);

		// merge user options with default posts' options
		if($options != null && is_array($options)) $options = array_merge($defaultOptions, $options);
		else $options = $defaultOptions;

		return $options;

	}

	/**
	 * Autogenerate a summary for a blog post from the blog body field.
	 *
	 * @param Page $page The blog post $page.
	 * @param string $allowableTags Allowable tags strip_tags().
	 * @return string Ssummary Summary of blog post.
	 */
	private function processPostSummary(Page $page, $allowableTags = '') {
		$summary = strip_tags(substr($page->blog_body, 0, $this->summaryLimit), $allowableTags);
		$summary = substr($summary, 0, strrpos($summary, ' '));
		return $summary;
	}

	/**
	 * Get an array of archives, optionally by year and optionally including a few posts.
	 *
	 * @access public
	 * @param integer $year Retrieve archives for a specific year (default=retrieve all years)
	 * @param integer $limit Max number of posts titles to show for each month, default=0 which means don't show any
	 * @return array $years in this format:
	 *
	 * array(
	 * 	2012 => array( // year 2012
	 *		1 => array( // month 1: January
	 * 			'name' => 'January',
	 *			'url' => '/archives/2012/01/',
	 *			'posts' => PageArray, // containing first few posts
	 *			'total' => 5 // total # of posts in month
	 *		),
	 *		2 => array( // Month 2: February
	 *			'name' => 'February',
	 *			...and so on
	 *		),
	 *		...and so on
	 * 	),
	 *
	 * 	2011 => array( ... ), // year 2011
	 *	...and so on
	 * );
	 *
	 */
	public function getArchives($year = 0, $limit = 1) {

		$pages = $this->wire('pages');

		if($year) {
			$firstYear = $year;
			$lastYear = $year;
		}
		else {
			$oldest = $pages->get("template=blog-post, blog_date>0, sort=blog_date");
			$newest = $pages->get("template=blog-post, blog_date>0, sort=-blog_date");

			if(!$newest->id) return '';
			$firstYear = date('Y', $oldest->getUnformatted('blog_date'));
			$lastYear = date('Y', $newest->getUnformatted('blog_date'));
		}

		$_limit = $limit > 1 ? (int) $limit : 2;
		$years = array();

		for($y = $lastYear; $y >= $firstYear; $y--) {

			$months = array();
			$numPostsYear = 0;

			for($month = 1; $month <= 12; $month++) {

				$firstDay = strtotime("$y-$month-01");
				$lastDay = strtotime("+1 month", $firstDay)-1;

				$posts = $pages->find("template=blog-post, blog_date>=$firstDay, blog_date<=$lastDay, limit=$_limit, sort=-blog_date");
				$numPosts = $posts->getTotal();
				if(!$numPosts) continue;
				$numPostsYear += $numPosts;

				$archivesPath = $this->archives->url;

				$months[$month] = array(
					'url' => $archivesPath . "$y/$month/",// note where our blog pages live vary depending on blogStyle
					'name' => strftime('%B', $firstDay),
					'posts' => $limit > 0 ? $posts : array(),
					'total' => $numPosts
					);
			}

			if(!$numPostsYear) continue;

			$years[$y] = array(
				'url' => $archivesPath . "$y/",// note where our blog pages live vary depending on blogStyle
				'name' => $y,
				'total' => $numPostsYear,
				'months' => $months
				);
		}

		return $years;

	}

	/**
	 * Return a featured image for the given post.
	 *
	 * Used by renderPosts().
	 *
	 * @access private
	 * @param Page $page A single post page to set extra properties to.
	 * @return string $featuredImage Markup of featured image.
	 *
	 */
	private function getFeaturedImage($page) {

		$options = $this->options;

		$featuredImage = '';// will contain featured image string

		########### if user specified they want to show a featured image we first attempt to find it in the page's blog_images. ###########
		########### if that fails, we check for it in the post's first embedded image in blog_body ###########

		// ** featured image dimensions **
		$size 	= $this->small ? $options['post_small_image_size'] : $options['post_large_image_size'];
		$width 	= $this->small ? (int) $options['post_small_image_width'] : (int) $options['post_large_image_width'];
		$height = $this->small ? (int) $options['post_small_image_height'] : (int) $options['post_large_image_height'];

		// retrieve first image with the tag 'featured' or user-specified 'tag'
		$image = $page->blog_images->getTag($options['post_image_tag']);

		// if we found the image
		if($image) {

			$alt = $options['post_image_alt'] == 'description' ? $image->description : $page->{$options['post_image_alt']};

			if ($height > 0 && $width > 0 && $size == true) $thumb = $image->size($width, $height);
			elseif ($width > 0) $thumb = $image->width($width);
			elseif ($height > 0) $thumb = $image->height($height);
			else $thumb = $image;

			$featuredImage .=  "<img class='post-featured-image' src='{$thumb->url}' alt='{$alt}' width='{$thumb->width}' height='{$thumb->height}' />";

		}// end if $image found

		// if we didn't find an image in $page->blog_images, we check for the first embedded image in blog_body if blog_body is not blank!
		// only for small posts! no need to get embedded image if large/full post! otherwise it will be displayed twice!
		elseif($this->small && $page->blog_body !='') {

			/*for each summarised post, we use PHP's DOMDocument class to find the first embedded image and use that as the featured image*/
			// we grab the first img found in blog_body
			$image = $this->findEmbeddedImages($page->blog_body);// default limit=1

			// if an image found, we grab its 'src' attribute
			if (count($image)) {// array
				// @note: we only requested 1 image so only 1 item in the array
				$imageURL = $image[0];// string;
				$alt = $page->{$options['post_image_alt']};
				$width = $width > 0 ? "width={$width}" : '';
				$height = $height > 0 ? "height={$height}" : '';
				$featuredImage .=  "<img class='post-featured-image' src='{$imageURL}' alt='{$alt}' {$width} {$height} />";
			}

		}// end else grab image from first image embedded in post

		return $featuredImage;

	}

	/**
	 * Get images embedded in specified markup.
	 *
	 *
	 * @access public
	 * @param string $markup Markup with embedded images.
	 * @param integer $limit Number of images to return. Default is one (first image);
	 * @return array $images Array of embedded images sources/urls or empty if none found.
	 *
	 */
	public function findEmbeddedImages($markup, $limit=1) {

			$images = array();

			// if markup supplied
			if($markup) {
				// parse the html string into a DOMDocument
				$dom = new \DOMDocument();
				// @note: we use to suppress errors since it seems DOMDocument() doesn't 'know' some HTML5 tags
				libxml_use_internal_errors(true);
				$dom->loadHTML($markup);

				for ($i=0; $i < $limit; $i++) {

					$image = $dom->getElementsByTagName('img')->item($i);// returns an object or null
					// image found? save its src/url
					if ($image !=null) $images[] = $image->getAttribute('src');// string;
				}
			}

			return $images;

	}

	/**
	 * Return merged user and default options for use in CommentArray.
	 *
	 * Used by renderComments().
	 * Allows us to pass options specific to Comments Form to CommentArray::renderForm().
	 *
	 * @access private
	 * @param array $options Array of custom options to merge wth default ones.
	 * @return array $options Options to apply to comments form.
	 *
	 */
	private function getCommentsFormOptions($options) {

		################### // @note: for backward compatibility (blog < 2.4.1) ###################
		if(isset($options['comments_post_text'])) $commentsPostText = $options['comments_post_text'];
		else $commentsPostText = $this->_('Post a comment');

		if(isset($options['comments_success'])) $commentsSuccess = $options['comments_success'];
		else $commentsSuccess = $this->_('Thank you, your submission has been saved.');

		if(isset($options['comments_error'])) $commentsError = $options['comments_error'];
		else $commentsError = $this->_('Your submission was not saved due to one or more errors. Try again.');

		################### END backward compatibility ###################

		$commentsPending = $this->_('Your comment has been submitted and will appear once approved by the moderator');

		$defaultOptions = array(
			'headline' => $commentsPostText, // Post comment headline
			'attrs' => array(),// @TODO?
			'successMessage' => $commentsSuccess,
			'pendingMessage' => $commentsPending,
			'errorMessage' => $commentsError,
			'redirectAfterPost' => true
		);

		// merge user options with default comments options
		if($options != null && is_array($options)){$options = array_merge($defaultOptions, $options);}
		else $options = $defaultOptions;

		// add markup to some properties
		$options['headline'] = '<h4>' . $options['headline'] . '</h4>';
		$options['successMessage'] = "<div class='alert-box success'>" . $options['successMessage'] . '</div>';
		$options['pendingMessage'] = "<div class='alert-box success pending'>" . $options['pendingMessage'] . '</div>';
		$options['errorMessage'] = "<div class='alert-box error'>" . $options['errorMessage'] . '</div>';

		return $options;

	}

	######################################

	/**
	 * Return merged user and default options.
	 *
	 * Used by renderPosts().
	 *
	 * @access private
	 * @param Page $page A single post page to set categories property to.
	 *
	 */
	private function setCategories($page) {
		$options = $this->options;
		// if user wants to show categories in post
		if($options['post_categories'] != 0) {
			$page->categories = '';
			if(count($page->blog_categories)) {
				$page->categories = "<p class='categories'><span>" . $options['post_categories_text'] . " " . "</span>";
				foreach($page->blog_categories as $category) $page->categories .= "<a href='{$category->url}'>{$category->title}</a>, ";
				$page->categories = rtrim($page->categories, ", ") . "</p>";
			}
		}
	}

	/**
	 * Return merged user and default options.
	 *
	 * Used by renderPosts().
	 *
	 * @access private
	 * @param Page $page A single post page to set categories property to.
	 *
	 */
	private function setTags($page) {
		$options = $this->options;
		if($options['post_tags'] != 0) {
			$page->tag = '';
			if(count($page->blog_tags)) {
				$page->tags = "<p class='tags'><span>" . $options['post_tags_text'] . " " . "</span>";
				foreach($page->blog_tags as $tag) $page->tags .= "<a href='{$tag->url}'>{$tag->title}</a>, ";
				$page->tags = rtrim($page->tags, ", ") . "</p>";
			}
		}

	}

	/**
	 * Add extra properties to each given post.
	 *
	 * We set a $page->summary, authorURL and authorName.
	 * Used by renderPosts().
	 *
	 * @access private
	 * @param Page $page A single post page to set extra properties to.
	 *
	 */
	private function setExraProperties($page) {
		$options = $this->options;

		// Note:we don't have a summary field for 'post' pages but left code here just in case we need it in future
		// only run this if post small == true
		if(empty($page->summary) && $this->small) {
			// summary is blank so we auto-generate a summary from the body [note: blog body field is 'blog_body']
			$page->summary = $this->processPostSummary($page, $options['post_small_allowable_tags']);
		}

		// set a couple new properties that our output will use
		if($page->createdUser->get('title')) {
			$authorTitle = $page->createdUser->get('title');
			$page->set('authorName', $authorTitle);
			$page->set('authorURL', $this->authors->url . $this->wire('sanitizer')->pageName($authorTitle) . '/');// use pageName sanitized author title in author page URL
		}

		else {
			$page->set('authorName', 'Author Name');// use generic 'Author Name' if author title not set
			$page->set('authorURL', '');// no link to author page until user sets author title
		}

	}

	/**
	 * Return a date formatted as specified in the Blog post's 'blog_date' field.
	 *
	 * @access public
	 * @param integer|string $date If given a timestamp, it will be automatically formatted according to the 'blog_date' field in PW
	 *	If given a string, then whatever format it is in will be kept.
	 * @param integer $mode Date format to use. If for posts and similar, use blog_date (default). If for comments, use blog_comments dateFormat.
	 * @return string $date Date markup.
	 *
	 */
	public function formatDate($date, $mode = 1) {

		$fields = $this->wire('fields');

		if(is_int($date)) {
			// for posts, use date format specified in field 'blog_date'
			$dateFormat = $fields->get('blog_date')->dateOutputFormat;
			// for comments, if specified, use in-built date format in 'blog_comments'
			if($mode == 2 && $fields->get('blog_comments')->dateFormat) $dateFormat = $fields->get('blog_comments')->dateFormat;
			$date = FieldtypeDatetime::formatDate($date, $dateFormat);
		}

		return $date;

	}

	/**
	 * Find comments from the given selector string.
	 *
	 * Used internally in this class.
	 *
	 * @access public
	 * @param string $selector
	 * @return CommentArray $comments.
	 *
	 */
	public function findComments($selector) {

		$comments = FieldtypeComments::findComments('blog_comments', $selector);// 1st argument is our comments field
		$blogComments = $this->comments;
		$gComments = $blogComments->blog_comments_view;// global comments/comments form visibility setting [only kicks in when selected AND post setting='']
		$page = $this->wire('page');// Page being viewed (Page)
		$admin = $page->editable();

		foreach($comments as $c) {
			// if this comment is not viewable for current user, remove it from the array
			if(!$c->page->viewable()) $comments->remove($c);
			// remove comments whose pages are set to 'disable-comments' if user is not admin
			if($c->page->blog_comments_view && $c->page->blog_comments_view->id==$this->dc->id && !$admin) $comments->remove($c);
			// visibility: empty/no selection in post comments && global disable comments set to dc but user not admin
			if(!$c->page->blog_comments_view && $gComments && $gComments->id==$this->dc->id && !$admin) $comments->remove($c);
		}

		return $comments;

	}

	/**
	 * Find a limited number of recent comments.
	 *
	 * @access public
	 * @param integer $limit Number of recent comments to find
	 * @param integer $start Where to start, like 0 (default: null = automatic, based on page number)
	 * @param bool $admin Include non-approved and spam comments? (default: null = determine automatically)
	 * @return CommentArray $comments.
	 *
	 */
	public function findRecentComments($limit = 3, $start = null, $admin = null) {

		$limit = (int) $limit;
		$_limit = is_null($start) ? $limit : $limit+1;
		$out = '';
		$pageNum = $this->wire('input')->pageNum;

		// auto-determine $start if not specified
		if(is_null($start)) {
			if($pageNum > 1) $start = $pageNum * $limit;
			else $start = 0;
		}

		// we show pending and spam comments when page is editable
		if(is_null($admin)) $admin = $this->wire('page')->editable();// we assign variable $admin the value $page->editable() method if argument $admin = null

		// build selector to locate comments
		$selector = "limit=$_limit, start=$start, sort=-created, ";

		if($admin) $selector .= "status>=" . Comment::statusSpam . ", ";// if argument $admin = true OR if page is editable. [Note: statusSpam = -2, statusApproved = 1, statusPending = 0]
			else $selector .= "status>=" . Comment::statusApproved . ", ";// if argument $admin = false

		// find the comments we want to output
		$comments = $this->findComments($selector);

		return $comments;

	}

	/* ######################### - INSTALLERS - ######################### */

	/**
	 * 	Called only when the module is installed.
	 *
	 *	@access public
	 *
	 */
	public function ___install() {
		// Don't need to add anything here...
	}

	/**
	 *	Called only when the module is uninstalled.
	 *
	 *	This should return the site to the same state it was in before the module was installed.
	 *
	 *	@access public
	 *
	 */
	 public function ___uninstall() {
		// Don't need to add anything here...
	}


}
